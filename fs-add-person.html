<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-radio-group/paper-radio-group.html">
<link rel="import" href="../paper-radio-button/paper-radio-button.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../fs-person-gender/fs-person-gender-selector.html">
<link rel="import" href="../fs-date/fs-date.html">
<link rel="import" href="../fs-place/fs-place.html">
<link rel="import" href="fs-add-person-result.html">

<dom-module id="fs-add-person">
  <template>
    <style>
      :host {
        display: block;
      }
      
      .row {
        display: flex;
      }
      
      .name > paper-input {
        width: 100%;
      }
      
      .name > paper-input:last-child {
        margin-left: 16px;
      }
      
      .gender-living > div {
        flex: 1;
      }
      
      .gender paper-radio-button {
        display: block;
      }
      
      .vital fs-date {
        flex: 1;
      }
      
      .vital fs-place {
        flex: 2;
        margin-left: 16px;
      }
      
      #next-btn:not([disabled]),
      .result-button {
        background-color: var(--paper-blue-500);
        color: #fff;
      }
      
      #loader {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: rgba(230, 230, 230, .6);
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0;
        padding: 0;
      }
      
      paper-dialog-scrollable {
        width: 800px;
        height: 250px;
        margin: 0 -24px;
      }
      
      fs-add-person-result {
        border-width: 1px 1px 0 1px;
        border-style: solid;
        border-color: #e0e0e0;
      }
      
      fs-add-person-result:last-of-type {
        border-bottom: 1px solid #e0e0e0;
      }
      
      .no-results-message {
        color: #666;
        margin: 16px 0;
      }
      
      .label {
        font-weight: bold;
      }
      
      [hidden] {
        display: none !important;
      }
    </style>
    <paper-dialog id="dialog" opened="{{opened}}" modal>
      <h2>Add A Person</h2>
      <div hidden="[[!_showDataStep(_step)]]">
        <div class="row name">
          <paper-input label="First Names" value="{{firstNames}}"></paper-input>
          <paper-input label="Last Names" value="{{lastNames}}"></paper-input>
        </div>
        <div class="row gender-living">
          <div class="gender">
            <div>Gender</div>
            <fs-person-gender-selector gender="{{gender}}"></fs-person-gender-selector>
          </div>
          <div>
            <div>Living</div>
            <paper-radio-group on-iron-select="_livingSelection">
              <paper-radio-button name="living">Living</paper-radio-button>
              <paper-radio-button name="deceased">Deceased</paper-radio-button>
            </paper-radio-group>
          </div>
        </div>
        <div class="row vital">
          <fs-date edit date="{{birthDate}}" label="Birth Date"></fs-date>
          <fs-place edit place="{{birthPlace}}" label="Birth Place"></fs-place>
        </div>
        <div class="row vital">
          <fs-date edit disabled="{{_deathDisabled}}" date="{{deathDate}}" label="Death Date"></fs-date>
          <fs-place edit disabled="{{_deathDisabled}}" place="{{deathPlace}}" label="Death Place"></fs-place>
        </div>
      </div>
      <div hidden="[[!_showResultsStep(_step)]]">
        <h3>You Entered</h3>
        <fs-add-person-result gedcomx="{{_newGedcomx}}">
          <paper-button class="result-button" slot="buttons" on-tap="_createNewPerson">Create New Person</paper-button>
        </fs-add-person-result>
        <div hidden="{{!_hasSearchResults()}}">
          <h3>Possible Matches</h3>
          <paper-dialog-scrollable id="results-scroll">
            <template is="dom-repeat" items="{{_searchResults}}">
              <fs-add-person-result gedcomx="{{item.content.gedcomx}}">
                <paper-button class="result-button" slot="buttons" on-tap="_selectSearchResult">Add Person</paper-button>
              </fs-add-person-result>
            </template>
          </paper-dialog-scrollable>
        </div>
        <div class="no-results-message" hidden="{{_hasSearchResults()}}">
          <p class="label">No Matches Found</p>
          <p>We could not find any possible matches. You can add this new person to the Family Tree.</p>
        </div>
      </div>
      <div class="buttons">
        <paper-button on-tap="close">Cancel</paper-button>
        <paper-button id="next-btn" raised disabled="[[!_searchReady]]" hidden="[[!_showDataStep(_step)]]" on-tap="_search">Next</paper-button>
        <paper-button raised hidden="[[!_showResultsStep(_step)]]" on-tap="_refine">Refine Search</paper-button>
      </div>
      <div id="loader" hidden="[[!_loading]]">
        <paper-spinner-lite active class="blue"></paper-spinner-lite>
      </div>
    </paper-dialog>
    <fs-request 
      id="request"
      loading="{{_loading}}"
      headers='{"Accept":"application/x-gedcomx-atom+json"}'
      on-response="_handleSearchResponse"></fs-request>
  </template>

  <script>
    /**
     * `fs-add-person` is a component that can be used for adding new person to
     * the tree and for creating relationships between existing persons. It's a
     * modal dialog that starts by collecting basic information on a person
     * (name, gender, birth, death) and then searches the tree for possible
     * matches. From there the user can choose an existing person or create a
     * new person with the data they entered. We don't ask for all possible
     * data on a person; additional data can be added after the person is created.
     * 
     * Relationships can be created so that the new person is attached to the
     * tree or so that a new relationship is created between existing persons.
     * 
     * Set the `spouseId` property to create a couple relationship.
     * 
     *     <fs-add-person spouse-id="KWMX-123"></fs-add-person>
     * 
     * Set the `fatherId` or `motherId` property  (or both) to create a child 
     * and parents relationship with the selected person as the child.
     * 
     *     <fs-add-person father-id="PPPP-PPP" mother-id="TRJK-NM9"></fs-add-person>
     * 
     * Set the `childId` property to create a child and parents relationship
     * with the selected person as a parent.
     * 
     *     <fs-add-person child-id="STGH-123"></fs-add-person>
     * 
     * Set the `caprId` property to update an existing child and parents
     * relationship with the selected person as a parent.
     * 
     *     <fs-add-person capr-id="MWFL-456"></fs-add-person>
     * 
     * If none of the above attributes are set then the new person is created
     * but they will not be connected to the tree.
     * 
     * A `person-added` event is emitted when the process is complete.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class FsAddPerson extends Polymer.Element {
      static get is() { return 'fs-add-person'; }
      
      /**
       * Fired when the process of adding or selecting a person and creating
       * any necessary relationships is complete.
       *
       * @event person-added
       * @param {String} personId ID of the person that was created or selected.
       */
      
      static get properties() {
        return {
          opened: {
            type: Boolean,
            value: false
          },
          
          /** 
           * Do these need to be public? Do we want to allow these value to
           * be set and read?
           */
          firstNames: String,
          lastNames: String,
          gender: String,
          living: Boolean,
          birthDate: Object,
          birthPlace: Object,
          deathDate: Object,
          deathPlace: Object,
          
          /** 
           * The ID of the existing spouse when wanting to add a spouse
           */
          spouseId: String,
          
          /**
           * The ID of the existing father when wanting to add a child
           */
          fatherId: String,
          
          /** 
           * The ID of the existing mother when wanting to add a child
           */
          motherId: String,
          
          /**
           * The ID of the existing child when wanting to add a parent
           */
          childId: String,
          
          /**
           * The ID of the existing child and parents relationship when adding
           * a parent to an existing relationships
           */
          caprId: String,
          
          /** Whether the search request is loading */
          _loading: Boolean,
          
          /** Whether the death inputs should be disabled */
          _deathDisabled: {
            type: Boolean,
            value: true,
            computed: '_disableDeath(living)'
          },
          
          /** Whether we have enough data to search for duplicates */
          _searchReady: {
            type: Boolean,
            value: false,
            computed: '_readyToSearch(firstNames, lastNames, gender, living)'
          },
          
          /** Which step or page we are on */
          _step: {
            type: String,
            value: 'data'
          },
          
          /** List of search results (possible matches) */
          _searchResults: {
            type: Array,
            value: function(){
              return [];
            }
          },
          
          /** 
           * Represents information about the new person. This is used both for
           * display via fs-add-person-result and to send to the server when 
           * creating the person.
           */
          _newGedcomx: Object
        };
      }
      
      ready() {
        super.ready();
        this.$['results-scroll'].dialogElement = this.$.dialog;
      }
      
      /** Open the dialog */
      open() {
        this.opened = true;
      }
      
      /** Close the dialog */
      close() {
        this.opened = false;
      }
      
      /**
       * Issue the API request for finding possible duplicates
       */
      _search() {
        this.$.request.url = this._calculateSearchUrl();
        this.$.request.generateRequest();
        this._newGedcomx = this._calculateNewGedcomx();
      }
      
      /**
       * Return to the data step
       */
      _refine() {
        this._step = 'data';
      }
      
      /**
       * Calculate the URL for searching for matches. The matches query API
       * requires a lot of data so if we don't have enough then we'll use the
       * regular search API.
       */
      _calculateSearchUrl() {
        const queryParts = {};
        if(this.firstNames) {
          queryParts.givenName = this.firstNames;
        }
        if(this.lastNames) {
          queryParts.surname = this.lastNames;
        }
        switch(this.gender) {
          case 'http://gedcomx.org/Male':
            queryParts.gender = 'male';
            break;
          case 'http://gedcomx.org/Female':
            queryParts.gender = 'female';
            break;
        }
        if(this.birthDate) {
          queryParts.birthDate = this.birthDate.original;
        }
        if(this.birthPlace) {
          queryParts.birthPlace = this.birthPlace.original;
        }
        if(this.deathDate) {
          queryParts.deathDate = this.deathDate.original;
        }
        if(this.deathPlace) {
          queryParts.deathPlace = this.deathPlace.original;
        }
        const query = Object.keys(queryParts)
          .map((key) => `${key}:"${queryParts[key]}"`)
          .join(' ');
        const match = this.firstNames && this.lastNames && this.gender && this.living !== undefined
          && this.birthDate && this.deathDate && this.deathPlace;
        return `/platform/tree/${match ? 'match' : 'search'}?q=${query}`;
      }
      
      _handleSearchResponse(e) {
        const response = e.detail.response;
        if(response.data && response.data) {
          this._searchResults = response.data.entries;
        } else {
          this._searchResults = [];
        }
        this._step = 'results';
      }
      
      _hasSearchResults() {
        return Array.isArray(this._searchResults) && this._searchResults.length > 0;
      }
      
      /**
       * Generate a gedcomx object reprsenting the new person
       */
      _calculateNewGedcomx() {
        const person = {
          living: this.living,
          facts: [],
          display: {}
        };
        
        // Name
        const nameParts = [];
        if(this.firstNames) {
          nameParts.push({
            type: 'http://gedcomx.org/Given',
            value: this.firstNames
          });
        }
        if(this.lastNames) {
          nameParts.push({
            type: 'http://gedcomx.org/Surname',
            value: this.lastNames
          });
        }
        person.names = [{
          preferred: true,
          nameForms: [{
            parts: nameParts
          }]
        }];
        person.display.name = nameParts.map(p => p.value).join(' ');
        
        // Gender
        person.gender = { type: this.gender };
        
        // Birth
        if(this.birthDate || this.birthPlace) {
          const birth = {
            type: 'http://gedcomx.org/Birth'
          };
          if(this.birthDate) {
            birth.date = this.birthDate;
            person.display.birthDate = this.birthDate;
          }
          if(this.birthPlace) {
            birth.place = this.birthPlace;
            person.display.birthPlace = this.birthPlace;
          }
          person.facts.push(birth);
        }
        
        // Death
        if(this.deathDate || this.deathPlace) {
          const death = {
            type: 'http://gedcomx.org/Death'
          };
          if(this.deathDate) {
            death.date = this.deathDate;
            person.display.deathDate = this.deathDate;
          }
          if(this.deathPlace) {
            death.place = this.deathPlace;
            person.display.deathPlace = this.deathPlace;
          }
          person.facts.push(death);
        }
        
        return { persons: [ person ] };
      }
      
      /**
       * We use this event listener to calculate the value of living,
       * as opposed to just doing two-way binding, because paper-radio-group
       * doesn't support boolean values so we have to calculate the
       * value ourself.
       */
      _livingSelection(e) {
        this.living = e.detail.item.name === 'living';
      }
      
      /**
       * Disable death date and place when the person is not marked as deceased.
       */
      _disableDeath(living) {
        return living !== false;
      }
      
      /**
       * Calculate whether we have enough information to proceed to the search step.
       */
      _readyToSearch(firstNames, lastNames, gender, living) {
        return (firstNames || lastNames) && gender && living !== undefined;
      }
      
      /**
       * Whether to show the data step
       */
      _showDataStep(_step) {
        return _step === 'data';
      }
      
      /**
       * Whether to show the results step
       */
      _showResultsStep(_step) {
        return _step === 'results';
      }
      
      /**
       * Create the new person
       */
      _createNewPerson() {
        this._loading = true;
        const request = new FSRequest();
        request.url = '/platform/tree/persons';
        request.method = 'POST';
        request.body = this._newGedcomx;
        request.addEventListener('response', (e) => {
          this._loading = false;
          const response = e.detail.response;
          if(response.statusCode === 201) {
            this._selectPerson(response.headers['x-entity-id'], this.gender);
          }
        });
        request.ready();
        request.generateRequest();
      }
      
      /**
       * Select an existing person from a search result
       */
      _selectSearchResult(e) {
        const person = e.model.item.content.gedcomx.persons[0];
        this._selectPerson(person.id, person.gender.type);
      }
      
      /**
       * Set the selected person ID and initiate the process of creating relationships
       */
      _selectPerson(personId, gender) {
        this._selectedId = personId;
        this._selectedGender = gender;
        this._createRelationship();
      }
      
      /**
       * Emit the completed event
       */
      _completed() {
        this.dispatchEvent(new CustomEvent('person-added', {
          detail: {
            personId: this._selectedId
          },
          bubbles: true, 
          composed: true
        }));
        this.opened = false;
      }
      
      /**
       * Create or update the relationship that the new or selected person will
       * belong to. Just one for now. The user can add other relationships later.
       */
      _createRelationship() {
        if(this._selectedId) {
          
          const request = new FSRequest();
          request.url = '/platform/tree/relationships';
          request.method = 'POST';
          request.addEventListener('response', (e) => {
            this._loading = false;
            // const response = e.detail.response;
            this._completed();
          });
          
          // Adding a spouse and thus creating a couple relationship.
          // FamilySearch demands that person 1 be a male and person 2 be a
          // female. We know the gender of the selected person and we just have
          // to assume that the spouse is the opposite gender.
          if(this.spouseId) {
            request.body = {
              relationships: [{
                type: 'http://gedcomx.org/Couple',
                person1: {
                  resource: this._selectedGender === 'http://gedcomx.org/Male' ? this._selectedId : this.spouseId
                },
                person2: {
                  resource: this._selectedGender === 'http://gedcomx.org/Female' ? this._selectedId : this.spouseId
                }
              }]
            };
          }
          
          // Adding a new child and thus creating a child-and-parents relationship
          else if(this.fatherId || this.motherId) {
            const relationship = {
              child: {
                resource: this._selectedId
              }
            };
            if(this.fatherId) {
              relationship.father = {
                resource: this.fatherId
              };
            }
            if(this.motherId) {
              relationship.mother = {
                resource: this.motherId
              };
            }
            request.body = {
              childAndParentsRelationships: [relationship]
            };
          }
          
          // Adding a new parent and thus creating a new child-and-parents relationship
          else if(this.childId) {
            const relationship = {
              child: {
                resource: this.childId
              }
            };
            if(this._selectedGender === 'http://gedcomx.org/Male') {
              relationship.father = {
                resource: this._selectedId
              };
            } else {
              relationship.mother = {
                resource: this._selectedId
              };
            }
            request.body = {
              childAndParentsRelationships: [relationship]
            };
          }
          
          // Adding a new parent to an existing child-and-parents relationship
          else if(this.caprId) {
            request.url = `/platform/tree/child-and-parents-relationships/${this.caprId}`;
            const relationship = {};
            if(this._selectedGender === 'http://gedcomx.org/Male') {
              relationship.father = {
                resource: this._selectedId
              };
            } else {
              relationship.mother = {
                resource: this._selectedId
              };
            }
            request.body = {
              childAndParentsRelationships: [relationship]
            };
          }
          
          // Not configured to create any relationships so we're done
          else {
            this._completed();
            return;
          }
          
          this._loading = true;
          request.ready();
          request.generateRequest();
        }
      }
    }

    window.customElements.define(FsAddPerson.is, FsAddPerson);
  </script>
</dom-module>
